// Generated by CoffeeScript 1.6.3
var Client, VERSION, v4;

VERSION = 1;

Client = require('engine.io-client');

v4 = require('node-uuid').v4;

module.exports = function(config) {
  /*
  
  * `config.connect.uri` - websocket uri
  * `config.connect.interval` - retry interval for connect and reconnect
      * does not back off exponentially
  
  TODO: node-bunyan logger
  
      config.log.streams
      config.log.serializers
  */

  var local;
  return local = {
    title: config.title != null ? config.title : 'Untitled',
    uuid: config.uuid != null ? config.uuid : v4(),
    context: config.context != null ? config.context : {},
    secret: config.secret != null ? config.secret : '',
    socket: void 0,
    log: {
      info: function() {},
      fatal: function() {}
    },
    status: {
      value: 'pending',
      at: new Date
    },
    connect: function() {
      var socket;
      if (local.socket != null) {
        return local.reconnect();
      }
      local.socket = socket = new Client.Socket(config.connect.uri);
      socket.on('error', function(err) {
        if (local.status.value === 'pending') {
          return local.reconnect('connecting');
        }
      });
      socket.on('close', function() {
        if (local.status.value === 'denied') {
          return;
        }
        local.log.info('disconnected');
        return local.reconnect('reconnecting');
      });
      socket.on('open', function() {
        if (local.reconnecting != null) {
          local.status.value = 'reconnected';
          local.status.at = new Date;
          clearInterval(local.reconnecting);
          local.reconnecting = void 0;
          local.log.info('reconnected');
        } else {
          clearInterval(local.connecting);
          local.connecting = void 0;
          local.status.value = 'connected';
          local.status.at = new Date;
          local.log.info('connected');
        }
        return socket.send("" + VERSION + (JSON.stringify({
          event: 'handshake',
          data: {
            title: local.title,
            uuid: local.uuid,
            context: local.context,
            secret: local.secret
          }
        })));
      });
      return socket.on('message', function(payload) {
        var data, event, version, _ref;
        version = payload[0];
        _ref = JSON.parse(payload.slice(1)), event = _ref.event, data = _ref.data;
        return local[event](socket, data);
      });
    },
    accept: function(socket, data) {
      local.status.value = 'accepted';
      local.status.at = new Date;
      return local.log.info('accepted');
    },
    deny: function(socket, data) {
      local.status.value = 'denied';
      local.status.at = new Date;
      return local.log.info('denied');
    },
    connecting: void 0,
    reconnecting: void 0,
    reconnect: function(type) {
      var interval;
      if (local.reconnecting != null) {
        return;
      }
      if (local.connecting != null) {
        return;
      }
      interval = ((function() {
        try {
          return config.connect.interval;
        } catch (_error) {}
      })()) || 1000;
      if (interval < 1000) {
        local.log.fatal('connect interval too short');
        return;
      }
      return local[type] = setInterval((function() {
        local.log.info(type);
        return local.socket.open();
      }), interval);
    },
    close: function() {}
  };
};
