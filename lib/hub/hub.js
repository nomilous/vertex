// Generated by CoffeeScript 1.6.3
var deferred, engine, http;

engine = require('engine.io');

http = require('http');

deferred = require('also').deferred;

module.exports.create = function(config, log) {
  var local;
  return local = {
    transport: void 0,
    server: void 0,
    clients: {},
    index: {
      uuid2socketid: {}
    },
    status: {
      value: 'pending',
      at: new Date
    },
    timestamp: function() {
      return new Date;
    },
    listen: deferred(function(action, callback) {
      var server, transport;
      local.transport = transport = http.createServer();
      local.server = server = engine.attach(transport);
      server.on('connection', function(socket) {
        log.debug({
          socket: socket
        }, 'hub connection');
        local.clients[socket.id] = {
          status: {
            value: 'connected',
            at: local.timestamp()
          },
          socket: socket
        };
        socket.on('message', function(payload) {
          var data, event, _ref;
          _ref = JSON.parse(payload), event = _ref.event, data = _ref.data;
          return local[event](socket, data);
        });
        return socket.on('close', function() {
          return local.disconnect(socket);
        });
      });
      transport.on('error', function(error) {
        if (local.status.value === 'pending') {
          if (typeof callback === 'function') {
            callback(error);
          }
          action.reject(error);
          return;
        }
        return log.error({
          err: error
        }, 'transport error');
      });
      return transport.listen(config.listen.port, config.listen.hostname, function() {
        local.status.value = 'listening';
        local.status.at = new Date;
        if (typeof callback === 'function') {
          callback(null, local);
        }
        return action.resolve(local);
      });
    }),
    handshake: function(socket, data) {
      var client, context, previousClient, previousID, secret, title, uuid;
      secret = data.secret, title = data.title, uuid = data.uuid, context = data.context;
      if (secret !== config.secret) {
        log.debug({
          client: {
            title: title,
            uuid: uuid
          },
          socket: socket
        }, 'hub deny');
        socket.send('{"event":"deny"}', function() {
          return socket.close();
        });
        return;
      }
      try {
        client = local.clients[socket.id];
      } catch (_error) {}
      if (client == null) {
        log.error({
          socket: socket
        }, 'hub unknown socket id');
        socket.send('{"event":"deny"}', function() {
          return socket.close();
        });
        return;
      }
      if (previousID = local.index.uuid2socketid[uuid]) {
        previousClient = local.clients[previousID];
        client.cache = previousClient.cache;
      }
      client.title = title;
      client.uuid = uuid;
      client.context = context;
      client.status.value = 'accepted';
      client.status.at = local.timestamp();
      local.index.uuid2socketid[uuid] = socket.id;
      log.debug({
        client: {
          title: title,
          uuid: uuid
        },
        socket: socket
      }, 'hub accept');
      return socket.send('{"event":"accept"}');
    },
    disconnect: function(socket) {
      var client;
      client = local.clients[socket.id];
      if (client == null) {
        log.debug({
          socket: socket
        }, 'unknown socket disconnected');
      }
      log.debug({
        client: {
          title: client.title,
          uuid: client.uuid
        },
        socket: socket
      }, 'disconnected');
      client.status.value = 'disconnected';
      return client.status.at = local.timestamp();
    },
    broadcast: function(socket, data) {
      var client, clients, id, payload, _results;
      clients = local.clients;
      payload = JSON.stringify(data);
      _results = [];
      for (id in clients) {
        if (id === socket.id) {
          continue;
        }
        client = clients[id];
        if (client.status.value !== 'accepted') {
          continue;
        }
        _results.push(client.socket.send(payload));
      }
      return _results;
    },
    close: function() {}
  };
};
