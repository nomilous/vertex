// Generated by CoffeeScript 1.6.3
var VERSION, deferred, engine, http;

VERSION = 1;

engine = require('engine.io');

http = require('http');

deferred = require('also').deferred;

module.exports.create = function(config, log) {
  var local;
  return local = {
    transport: void 0,
    server: void 0,
    clients: {},
    index: {
      uuid2socketid: {}
    },
    status: {
      value: 'pending',
      at: new Date
    },
    timestamp: function() {
      return new Date;
    },
    listen: deferred(function(action, callback) {
      var server, transport;
      local.transport = transport = http.createServer();
      local.server = server = engine.attach(transport);
      server.on('connection', function(socket) {
        log.debug({
          socket: socket
        }, 'hub connection');
        local.clients[socket.id] = {
          status: {
            value: 'connected',
            at: local.timestamp()
          },
          socket: socket
        };
        return socket.on('message', function(payload) {
          var data, event, version, _ref;
          version = payload[0];
          _ref = JSON.parse(payload.slice(1)), event = _ref.event, data = _ref.data;
          return local[event](socket, data);
        });
      });
      transport.on('error', function(error) {
        if (local.status.value === 'pending') {
          if (typeof callback === 'function') {
            callback(error);
          }
          action.reject(error);
          return;
        }
        return log.error({
          err: error
        }, 'transport error');
      });
      return transport.listen(config.listen.port, config.listen.hostname, function() {
        local.status.value = 'listening';
        local.status.at = new Date;
        if (typeof callback === 'function') {
          callback(null, local);
        }
        return action.resolve(local);
      });
    }),
    handshake: function(socket, data) {
      var client, context, previousClient, previousID, secret, title, uuid;
      secret = data.secret, title = data.title, uuid = data.uuid, context = data.context;
      if (secret !== config.secret) {
        log.debug({
          client: {
            title: title,
            uuid: uuid
          },
          socket: socket
        }, 'hub deny');
        socket.send(VERSION + '{"event":"deny"}', function() {
          return socket.close();
        });
        return;
      }
      try {
        client = local.clients[socket.id];
      } catch (_error) {}
      if (client == null) {
        log.error({
          socket: socket
        }, 'hub unknown socket id');
        socket.send(VERSION + '{"event":"deny"}', function() {
          return socket.close();
        });
        return;
      }
      if (previousID = local.index.uuid2socketid[uuid]) {
        previousClient = local.clients[previousID];
        client.cache = previousClient.cache;
      }
      client.title = title;
      client.uuid = uuid;
      client.context = context;
      client.status.value = 'authorized';
      client.status.at = local.timestamp();
      local.index.uuid2socketid[uuid] = socket.id;
      log.debug({
        client: {
          title: title,
          uuid: uuid
        },
        socket: socket
      }, 'hub accept');
      return socket.send(VERSION + '{"event":"accept"}');
    },
    close: function() {}
  };
};
