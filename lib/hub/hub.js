// Generated by CoffeeScript 1.6.3
var deferred, engine, http;

engine = require('engine.io');

http = require('http');

deferred = require('decor').deferred;

module.exports.create = function(config) {
  var hostname, local;
  if (config == null) {
    config = {};
  }
  try {
    hostname = config.listen.hostname || 'localhost';
  } catch (_error) {}
  return local = {
    transport: void 0,
    server: void 0,
    clients: {},
    index: {
      uuid2socketid: {}
    },
    status: {
      value: 'pending',
      at: new Date
    },
    timestamp: function() {
      return new Date;
    },
    listen: deferred(function(action, callback) {
      var server, transport;
      if (config.listen == null) {
        return action.resolve();
      }
      local.transport = transport = http.createServer();
      local.server = server = engine.attach(transport);
      server.on('connection', function(socket) {
        local.clients[socket.id] = {
          status: {
            value: 'connected',
            at: local.timestamp()
          },
          socket: socket
        };
        socket.on('message', function(payload) {
          var data, event, _ref;
          _ref = JSON.parse(payload), event = _ref.event, data = _ref.data;
          return local[event](socket, data);
        });
        return socket.on('close', function() {
          return local.disconnect(socket);
        });
      });
      transport.on('error', function(error) {
        if (local.status.value === 'pending') {
          if (typeof callback === 'function') {
            callback(error);
          }
          action.reject(error);
        }
      });
      return transport.listen(config.listen.port, hostname, function() {
        local.status.value = 'listening';
        local.status.at = new Date;
        if (typeof callback === 'function') {
          callback(null, local);
        }
        return action.resolve(local);
      });
    }),
    handshake: function(socket, data) {
      var action, client, context, otherUUID, peer, peers, previousClient, previousID, secret, socketID, title, uuid;
      secret = data.secret, title = data.title, uuid = data.uuid, context = data.context;
      if (secret !== config.secret) {
        socket.send('{"event":"deny"}', function() {
          return socket.close();
        });
        return;
      }
      action = 'join';
      try {
        client = local.clients[socket.id];
      } catch (_error) {}
      if (client == null) {
        socket.send('{"event":"deny"}', function() {
          return socket.close();
        });
        return;
      }
      if (previousID = local.index.uuid2socketid[uuid]) {
        action = 'resume';
        previousClient = local.clients[previousID];
        client.cache = previousClient.cache;
      }
      client.title = title;
      client.uuid = uuid;
      client.context = context;
      client.status.value = 'accepted';
      client.status.at = local.timestamp();
      local.index.uuid2socketid[uuid] = socket.id;
      socket.send('{"event":"accept"}');
      peers = {};
      for (otherUUID in local.index.uuid2socketid) {
        if (otherUUID === uuid) {
          continue;
        }
        socketID = local.index.uuid2socketid[otherUUID];
        peer = local.clients[socketID];
        peers[otherUUID] = {
          title: peer.title,
          context: peer.context
        };
      }
      socket.send(JSON.stringify({
        event: 'peer',
        action: 'list',
        list: peers
      }));
      return local.broadcast(socket, {
        event: 'peer',
        action: action,
        uuid: client.uuid,
        title: client.title,
        context: client.context
      });
    },
    disconnect: function(socket) {
      var client;
      client = local.clients[socket.id];
      if (client == null) {
        return;
      }
      client.status.value = 'disconnected';
      client.status.at = local.timestamp();
      return local.broadcast(socket, {
        event: 'peer',
        action: 'depart',
        uuid: client.uuid
      });
    },
    broadcast: function(socket, data) {
      var client, clients, id, origin, payload, _results;
      clients = local.clients;
      origin = clients[socket.id];
      if (data.uuid == null) {
        data.uuid = origin.uuid;
      }
      payload = JSON.stringify(data);
      _results = [];
      for (id in clients) {
        if (id === socket.id) {
          continue;
        }
        client = clients[id];
        if (client.status.value !== 'accepted') {
          continue;
        }
        _results.push(client.socket.send(payload));
      }
      return _results;
    },
    close: function() {}
  };
};
